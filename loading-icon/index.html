<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fe0846332e5f00869e1526a77aff5bdfed688b9fd85d29b67b7a7c18f4ff7ccfd8350cd6b06b1e8033e31eaeb1009363ccaf2914d3a7a572dcc7ef719bbf5a76a56876f872a5ef64f4a9351721f107a2b3222fcf1ae343ad678b9265fab8d7344d6596c72ee173eec31bf827b5adfac70ad5350f4ff90a0df5f58156937b7b543f0c79576fa7365b72ad700fc53cfb685743b1a8992d6fb773e3556c051242a230b9a4bd0102a2d13322ec515845d195e6d02a4645d8d0b68b299c8eed48c8fc5fdb7f16ce8ee68603a302dcfc57922e5e78af17ee3954a84f3a361a36de386dc71ca737c5b97713cea74eecdcadb00400dd8fafc98d42512d1307b31092bb4175ddf97d077d371802c260cc7c16d164e1ddf0c808a372bd7bad35596e21cb11494fcecee8a0a93bb2d3f7cae69b60453e0da23f390c328b8c4962292c34917a5086ac47a35139dfe3a635bceb65ab3a66830ee40989914651477d6a427286434830171dea744f77787f1f27529c4dde938e5c5b997947b2000c6e789d6a01930503704c40162e1af9547a020147d3002df4c54a27712815219d01bc0670a3b7df30d808a70a412dbeb6205a6b1fe0ed822532650ac8d59314be7b9660c293d64fc06b3d2ac87635ece6ba1d95fcae4979560c354c463d69be9fb37358fc2f22d2bb59e208a59313c28765ae16780a5a2e282bef508e08fb7dcbe8464e39e201dbbfb60f5bcf0e3e4bcaa1ece6bf3de05e2f2347f9a373ed20f96013873a2d1bc2aa54390c54acde7c0d03c7e0483cd04b7174c44fa370a9c7e4b6397ab651ab7c3b5c4550274130167302d86918c2cb6d0280b84525b431f302f2a4b8d5394e737f623ce20eae54f38fdcacb98fa782560db4236afbc3ebdce88234ce6c1e52ae478ce5d698a33fed9579b3c1cc5f301d1573bbfc60b7e89fadfc4a19806a21827d80ab377369410fb83f005896d0deb4ffa53fe07b8175b5e3fe364ed40dfd75a9877af065cb485be11a7235ac8a17e4a7a7d982f34e70bf33b38411b08ef9712e25b0a01a70e137207edb1e427985999a0746c4e21106111988037be85fe2c5ce10d9264dd85699e551a84f5d7a8566cf72275a590fe7b283db925fa267686b41c4578a5e43e9583dafe92849204945c7fcd0a2d9c7477fe2bc2d3630f86a9725b6c24534f903de4d190006240f8c448b183a51565b2e7b55427622a3e3828951d895bb49192c2f6a410cc988124dd3f0eb867c5778e7b01be37e1859c4e26692e53452708ba21f0210eec9d751775f309584fe50db35eb8284f18f5f4ba09b32692dabd836cfb6b2e1704ee8fd66bc9394e966a14b20ebf8c74021bc2a40901509ee33c11bb305d3b1a58b18866b8c9e5b5ba1ffb02af3b9533bb8fe8c01d8372e538c1784e4154279258c1c342db877a3753e7b123743514579500f52f9424c05e6073351860f1d8283074cde90b30308a973ef74941fee62e939b9e339324ffe92f6d905b3c7c70cb061fdf306320a1b865d68fb96371725d2d1032d211823f1f2a673635f763352f61a9c30212dac175c39db4055a228ce06a874575ea4e99d9a7d6907b59573aef38e6d8f444956f0106add9e30ed4b6878101a2cc1f24727b5551f2533d10ba84ef1417938625cb9ae57ce835315d2918905ce11359b60d2a52c4c8493c2994d29bc47063c7abe5d6a9805a008665e72f0b6aea3d7d5a9b09924b03d7816d283c870628bb145b3f0eb7f3b754991d5ece407148768ef18818e000ec6f9083d1a5dae69d13591eefde303db0996a80e97ccde099db6ed3d8eb76c99ff91cd4348633c4f6edef2a5282d7e0251eb5b39acdee42a8e19997db3de562ae27a70efbbbbf5894b88f93ca27886b35c7bc0723c8abaf0d08e1d4f287a11693a80289a00efda9b99c6e3a931db7666dfd9286be9d143b3f74d037b89749b7897ae44b52a91558410cf8bbc90475cad2e028dffa2fc32c43f4c3c599f82140097d1d33a4c2a9a027055ddc92220f497b92bd21e8763f316ff330ded813a4d878b6449b7e5b3bc01dfb91f5184d7f0aa5c8a2d0d85938149d6b4ec5c95c223560d8db3a8761c345fdeb6061a60ce2f447b1edba638d4f173565582421882aa9ec47db5f7cf5b9d008de349292e104e2991e30456120345522e30844411c1f32a4a7b963fd8ee7deb684651fe9df8bc1654fa175e5b8e23e81e077be0741434786dab2fe74777805b511f3ab5528f44e296f7a72de08f462ffbcea97c2a225f38b5a3c55688f0a56e53fd66ed87b46a8a030dddde711c4088e2cd7fd7114506e911f95c7513b5657df3276d51d31608fdf09270ca2d4ef2482d81fae5ea63dc5df8540fba9e7c1d24a9c97897ac652f49e02a9e91e41ec261a3346cf98d3e96915c07a946a8fda0ca43e8158edd08bdf7f64fc0411c0397917923018bef5e29d3728249f8cdfdacd16f2d37a192abd45cfbb6aaf9e9961a13fbd24e759429c3e949be8be0a5f5b158eb18582ed8d6602837bf61caae7d3fa7673cd83a11b02c651bddfd4dd7c3acf4419ccd1f884992ec639d1154454b370340d850846a41bab9357a68ac0f524b04ec261948ae309c6255efab342d5639cf43b853b6728bea3ee135c2945830347116d06fdf0c1899605ca12aad02bd747529f5d084f17b62fae8ddfe58f0f45e2ca2b4b38e91a44f5505e8bf39f358f5252edbc472575e899ca39f723c45fca9ab44a36d7dba54a2bfa7376980cec674acf4ed4d51eeb0db929b01865789d824c66769499cd4921ce33e6e38391d35db766ff881f3fdac9bc8ce763e89c3514049ef8f4928579663527698421d190d6e39edd3084b7739b6fb72eca1fe6e6923645f349b852cde5be1f69664bdcf5a0253f8bc964d20c609f5cbbb93fdba55154ae5ad7d521f4bdb646aa5698d634adbb4a0f17795d178d7d86eb6f93835b2d6b2cae64608686ff99fbd102d69d8d37fc3ee070d72206786cff41b72a01eb5acc3dfdabc8cfbbfbbbe61316b7f9400ea71cb495fbf10fc9a44575dcc0813eab6c68b3a73898387ea702b1ed3f909abb08be77ed03ad9be5d6476eefdc93702224a85c788b382b70fad9b23d2f1281429720b04e4ea5c2b25a743e94f785af260095472278df6833c29ccf302072cc8936b90e71c58c681ec00a47a7cba6a9f15ce8257a0464dba356b4ef31d5c0b11a45f2014702e768d3badd56123b5550a02cc8c1afcec0f11579f69185e85534146825ebcc2922e4fa1a26291d0fe77f89028981238969d7522c395485bb7f8692e67cf661b7d3510120c5455ba4c7860e6b666c3655db1edc362729968ae59537eaaa6b5f14fd6e52f967969c59ba5413686c052c53145a03e4f8204e476dc4a28db3928e0ae56c304622e6f0da6675def252b49635c6b285da2325b35c6fdcd4de6d069f2b5384e7b3992088aaedc64e0cb8aa07148a338b24661e525d5b312ad179d1ef41758a8949efb063c08a36b285927228d12e703bb591046d3a7ae00e05f12d5ba372b8fad28f02a20e0ead7f965edd80e6a3a9be97c86bc2509ea7d2d0533f1d2f4f7737cfcfa85305322d9317f070c8e0f9097be4be2b3ffb463c9cae4a5d630dae934a37d08181e53b674f7e89d447dec69d2911b8371255587b4550fcadfaa2421a7f4220ce9b705312913613af6a6555438f73a0e80aa9a9fbbec79b0a0ff0e808ab09de78175f43a5c2e050f7def9dc1663f5e3f731d99a944c2285d31dfdaf795ea48fda48d87e1850415bbf652657ce30428567863e3ba8a8789904d47fcace75d3310232966cb524c8ef208e2d670eb5e95955a51adbad06e6ee0985f8187e81a0ed2253cd8fcea4a3237ec238fd5da00b1959ecb28c42c97f2527a0dd658ed152096b1e6798b9f0018f9dfb18a5e647b636092b04c5d55994cb154f4ee6673a9f55fe1a19b03e6238e0cad74fb657ee4aca309d870ac8628d1d1ad92599bfefffd591ea9bc83523e3c95c21b7f4e2361207fffcc334e0fee7bad06f56055a8eed9c3c3507fdbcf4336b41cfe414f38157df3efcac6df28fbe70f40dd3fc63e7f6d06a146e1ca20d61d8a6ca4fa2a09023f2c1f66f47bad6369f19d8866b9d26d884b3dc91a256e7343924b6c616e50a4f1b5948fecd649843315aa831ef1768d3044b4fc10cb352f0ebd8a0bc694f7931cf798f07f982ae3dd76ce182bd058f7ad5c686ee259365ebf25cbee3a0039ec58f7a8a78a19849612b5b318fca01bf8547bd083e81e16c8798e6df79732b5c305c3187e3f402d15825c3215f4478e0bc986c9321c1e90a745b927f43a5af2d7c5310e64c9fe18ab430ea57737ae99268e698e17589bbf21bcb92915475b2f18748018ffdbba021592f3e7e10d08051ae8460cae25e5d646817e566f86c62e67d7fc622ada751c126e7464889804d163134c0082909c4ca0e9043f32d4c71ed0c00c4b852696a46ec00bd3aa459327af4db6a92151cce595cc09aa0b2401e8d5beed7a3cc38f8743f01d0e30ef6916da42dd845deb8d4a614614864de29834a77d4659634f06b5fb01e43fdcb92db7138bf008d263e73bf7da567d8853eeb2fe90589915835679d2571c597a4c94e3db3a3159ee552f63dd08323b0f4e7c1fbd7797b67133510d3caa89ebd940e54cd3d0717a012ff36d243a14b5601457f83b82475cb70ae54a24a27ecada40d8260cfe9866e5e4a5c9b6876411ad7e5f3ed959ba96d07beeb75212c456294204849b7d3b93fc4a1e81edf0120c82e8c6f502c71badf032454d7dd73d9d4ca9f4de62f57fcd91c79ba0e773976331bbc0c29901a0d757159e1c54760f7ea96f9ced38b91dc77367d26ef0f7975bf060f1227b077125eb3ae0083f169c7496901de24a6a7f5277a81ca86309b121c4179c7855ca0f7a188fc801351f6947b99db0b9d0ed42fd7495c2c16ae7bd397c9bb897a89fcfd0bd207f8f02b6a12e2b009dc0e1116dfcd96e451be650c8bc17be32dfedad2b8d813caf90b84f19400af7304bb96c4d23a3dbe9eec572c7907eac367b6baed6ef1bde097f827975f896bf137771498f1fd9c4682db15c193b4c17d2eb06b6c0ca15d00af3a69358cc6b2bab62f1d08cea3925b2d06ea6f7d31ef4c2974cd596e5ade93722550d773d57cfcc5603a11214290db7bc75f1c1fbaac3a26ddbe80498556858826fa74de3bc5fe5145e67e4a7bc989b934ab75dc7846812f5a530d1e9d461cb0691a3b3e68a959636a900a7bec7ffb9e24c1990b58180f666934fd8aabbfdb0407955980d0d6d366b32ba966f37b7acbf8af94c73aa1777a8f35080c8c13afc7364179c53df208fa09f72774aec86c07640dabd0afe8d0266695c83e0b79bb8e57e4347148b6855333295659f91716b60b1264f61e0c9d431387452544fc4bbab244d34763cb7dda3e31838569d23058f18d2d32b7b2477757f551bd168e6547348db2c4398a43d1912274515504d8c4fe0c93814fb9c7e28e4989d8ab57ad4f3f85641e9ca27dabb7d2b11b927e4326eae9b04ec67ca6ca5d1eeaa774c349938749323d4cc952d98a6fe7a7bf75187ccb67519ab08fa828eda83161f1e88c86ae6caa48334a4fa6afc6671cbce8929ed596f9b00b8e1808d69234b9f66af714189c300dff1a10dbc68b676cd1f9a7d063290e9f4791b4f1eadb326d90f890197add1b6433f24390ada7e65604ad552abcd27e1ff11d8ee47cd1c660bb8ddc527b6ca7a1d79b4a468f95d4038e2ce372e7d245f3c80f42cfbe51a4f033cdfc7e6f65674fb2a7f5aa941d0c7a0a691fb19e4061489d6de8919754ebf4928d92ee400f3a2aa3c0cf5c02cac22332f3eea6c93adb99a9e73bfef7797626160987a4a296b75175847235440f461ca6e800d4438cc5d1a77b1b8a501d188069e27018c8316c73dd029bd3125f4cbe4365846b993d3f0ade11c4e5f4a6020a547939c7ed78ab2f33bc6a78bf66363bc74ba05fe33cf06ace6c4f839ad7b8210906653941f086afb302d27d40120b757d2801424e251a55217e61b176ed6ac391c2b60a34b1b8337e708fbec575d2b3a33f7d4cd501b5558c8e46ab12a4b8d7fc48c6e722f2600a9e84214e49ea3fd8da576417febcb61963e7529166766b1660f8161de65f58a74591ed9799dcc076410e96d3cdf99322b51e04145e003b1b75a421522dcb70af60f45ea06592640ba109af38b199f87ba4ad994f380951a376ee90a9e160ddbd6f6a9c7c66b168b397a95e037e318bf3f25fdfb6be1e7afccf3b666255333dfed61ceec1f340cd13780ad03f118e956a3581b9e5eb93ad200a5caa680c28d083d336e50f72862a7ebcdcccd6eb2b7ba4ce0bc8740c7275e7b8515b3b11f273006c195af229f91b7ebe36e52ee18ab1c645fd87d789df204030e6e83e2685b5be8b4ce704eb8d2f3978da7c41aef8d951fcda9af8bbde20f4c5b66af9cbb67ab18a271bd1c76c9a17e51cbf9bcae24da7f13caadfd58ffda839b53c5bf973ca56c8912720c171023a0eeaf9157858c078d42e34ab64ce966ef3d4a6213bfb08db3955bdda4de37e6fa1c4bcbf413b14ca6623c96b3c8aab49fbef76fb52510a03c63e0504ad3c9e05f6efcca9db1c75230b061673db52d8133842b9a87763cc357eafb27c61a15fe6f4ff5c642bb2cde2e7f39aa09ea07ce4f3f2756aab7a502500826334545fa58d0811430993242b7f7b57fa27bb44acf7a68548df8b98506da5d8ba6b8a818cc560e287de18b6ea349f2a129cfe327d5291f0679f1c061423f7eb3cbc75ddc0364d3ceea23f126a1353781661f54de7648b76e7381f921479282cb55988f8f0a2e7bd82a6767965ba3419b659a67363c67df0c29f2340f91c9561ad15e2bf82acad2ff8d79a1c7ce33d166a5c49895ca5572b0d40785565b93f1726c79f9c61c256108cae9fddb772b3adae05b1d77934bf6a117e45608c9687af3bd423d5271e447977f52ce95e5b6a3381f9a7adf80fe2245123dce1931b71047d6ffa67885c30915694dcc806b7e1be1530d55765b8860cfb6071b55a5fc3a3ca74659a96d01addc1c53532d3ec476e34568fb473463cf106ecf2482962d10514f08e50153ca48d79fb0643e5856974a9b2f6e85bfc0a59c2d5bd8b2fe534417e6bae9fa182868d7c9e13ec78e930c783c268b7ed618ac4dc526c43579b73548f0d6b9445c138a87b4b7a25f11248dfa7cc430bf45a276b4e4abbfd20301f13c43ec60735821fedab654ef0cbeb6028cb0f900a716e4e254d103ed2dbf645be9007cc8005ab76779d69768d0d8d3cc7fae08eac2bf3fefcae3f0747942564e3ad17fc8c64b3bb3ee6982e8b282b047b3f8851f314577111012a0567ec8a4037b6d7103701292c1ada3760aded07af6a277a0dc8dba52130add0f8c69a96499a87f65571d04124ad82f5e121a805474460a1e4c06a1bd3860afba5ce95f59c3befdd3ef63dac35fd9493c66dea340aa2295cb4722e04f5c56b548bd369411992bb74bee6375334e42977e105d27f44d03dcaf13ceffa907f6a78fed10ea3114abf249a8bf411a4c9c44c115fd32821ca174c3d9e62a7c423b49b0af3fb4bef3633506ccfa8d97d61325d6dcf69448c72fb972b22c3917272a447e5b738eac72c4525240c566d09ba04756f771d161f23eedfc429213962047f4176c1b4686d962ba22f3013690f0faaa94e4d4394bb3d87b4956de7eaf556d4505410a09794a5e2ba13920c65e1ffd70ac417762e0ce207a382d337f1b8ac3fd0eb6e0929fbfb77bc34540867dd6ba2d5fde16444dea29caea597a4f43125b1c198cc46ef005a87a4617e65015ddcdc74038b12c586a82338149ed7efe6d5079482853f80cd7116919f540fd5cd8795d8659eea3ce21ff826a3cb323fbf3a02c8af094f718a743682b67568e0adc061b0c39bc45e1347ab487994d49770ead858fbc3fffa2763dea508ecde70ea4ec8e99e7b6b58dc19c057ae3d633393bdc8c9c2fc907dbd4441385617ad76dae895ee37060db4b0e44b5f4b017955443a9ac0cf9eaaccb3f2afd9679d84b8dc36c448a984199a77629c1413fb2ad7970e54383f6996f42727ba5797bb6fc1dfd9e8d47d4e3ee2f99336e08a1ae6536ad477eb14e86fe4feed1ee0a5fd36bdba568d2e3544a458f3a0ee8ce62497ddd044828f75484ee5582128bbb7e7c93163ce7ddc4bbb991b5f11e40751e8ded2c2103ff341bb838032f34f7f3ad4b6889a52963b2b57237e23ce19419266a50fc06b0e37e69b569c2b5b98ea6b7af19dd2e4fd6e4c55dce8b4309b0f9a7b080918d81b52fd305cc265f54fd7c67e06488456e8e31f87601efa3e2615e690fe7d4dd1146b2a112e94349cc6f1d9b9d3bb9714245179e37e1fc044cd61023d70de383fcc4206a243fd53ffe04cb952b2ed6b6cf004844809175d658aea3f18eaba1b2228c2c66e444d8ed29d801619918321ca957e03d6edcbe2673dabc87582b6724998a6595baaa4c218abeb6f324ec58d76b1255c7127558290de1411e173687ec2040bcf19f415bed874e5f71a0e75994d7939964516e307b73c484231f8184ec9f7916983a22bf7a616d136d82ff72d19384361dba5d9f46c94217b343965ea70b4c75b268ecaf312ceefa9fd2f2f1b86ccb0a12628774524ec8602ac8ce25e3daf5161390a0ad355cb3e5749f67fbf8c85543b989b27629e1907a0adc1284629c878ef3265d09773dca7d04e2c030f68fc281024c0927299c556c53a3dab0fc18363b5922e5ed777e3ad80280795a752369a3a005d2ed68dad179bf84a3a5c67de80cb588b73637b0f66957cef280e8e79fb0a1c6785b7a0a2a680060c9d25d1d96c10e5f22c97518203d18e240f40bd15360922e931fa28249d7391ed1643f5cf8cf0bd814f3ebcfeedd2f5a60afa3069bc36d19a87185557885df7b44badba04b7d544e09af0658ab5f41b97aaa33a3c32f1bd9cc281a0a72fcf893fc0bf52ae6a62f6650abee9644d4c784d3de6f54c72fcabbc641dcfaf902b606c97764183315b4ee163310f46b0aba91f905fb935e6ad5d3373f550b9e5012db8155a2a91fbd9e1347d7f2bac8dcfb11806e6cb35f6b5bf57a4b57b2a6daa69d42eec823bcd8ff9c0ee9ba4f3dddfb62449cb8aa7234464c389687826d37b311e8f0dee089689c8548f013b41dbf61621d230592e294f221f39417885b02f992ded40ad0501c5acf8d7ccbe9ee00e1418aab7f09cd96042c23cec01a8bbfd3562c133237a42ce6c701fa60ae5b33e70b97f037b29b03e277ca058cd4da3d63508e371362c1c030a27f924792cd28379d8b2949a2f8ebcb01d35ae7bef0ca04ba539a51be20625bc4c5c7a919440b06227c69837404a43c1931f81ce08700076b76c7e393395c7cf38abc59db5dea306d92e445f46f98fb4522ef61d50362dbde5afaee5f1a938bde243b6cc6dca909613d71f7d11bb5c806658381fd34e652474db2f41587750f7682c68ceaf00f87a7bae0234d60ea0a74a93443a652193616eca0ec09853ca2e1edcc13b85480ceb7398ce46f80c6d5a73cd046d633ca9948d1aa2400723850859e101e0693cc9c65364d120b91e55b96a5e1bbaba535693ffec684a7d8455b77c8b3411cd23b051a5a70d023470f322d79bc4568e47e2d066cbf0b1d266632f2810cae3cff41c163843876130e8490aac3a9e2cec75551d881a0e58447d319aae6f1b43fc89e6d639c434211ec76cb572d72f272eb1adb378f729ae6da43caa8d4f93430b1010de1b40a8513d483e41f40072d5f0162beac5a9e20ca5ac4d9d990cf2de7ccf925d19cd6efce1fe09a0028a8cf4794c21c41cc5e8b3d2810b24ea5f182585c6085a106d84449f8ac94ab9c0473fe6c87c9971a1df0183cd698c8487e19bf73b814011459f4a889dd77fcca1a81629e21671a88501ab53e3f90956dbd93525484fd7425c3e6a79728008c543e44e10eb2fcf21e9e8703df474b11ea7f7c0c3f29d12c36b4567781066b383b93dc004445a6b89b5473514502fd0a230351d794f0cc78f7376965611c529d7fc4f7788f190dd9575e1e79012096292165f0fccac8f7ded9239bcc6a05ad01b4f2e577a6be51eb3cc409fc2d9889017f261399438e4b7d33413efd3c41d055a762ed4fedf7b7f33645d842e51e51e69b7226e82191a728e95997a93e9ef3bd627d375f3346cb6b07abd34365b6712ca98491c45ab6c38daba3281307f66b73970d47cef2912a3920358d6f6e9636e7f151308f852c6337d04d8a51619d0ace94b0d467a1cdcd1a95658a746149a8ab7bec0f890ac24701c4af49df8f2a26ee6fc4bfbbfeeda15d804dfaf7e8fc5696cc98b1335641d7d809f33870702bce5ba5c06c08449c849fdcc642bde0931f9e451cca2e33e014695daabc34cdeae9bbdf96ef683c88bdcb20c577ab2df46a74a42a5bd56485a86706862f0ee6582e65813f302c20e11a2cad294085f7db24bfe41b457f5595d638902a2a3f5a28f391e8364ee1124db8ea3a437ea4db8f9dd31521f8a58f7de0dc988b643de4812691822a4d5272747371dd893daa285525004a1195d651435c4174ed9610cec8aedd464889a3300415cbf6f4d71afbb16a2ac2ff1a75b24f9869ea3083b7fe3c65fbb21fc6e2c0a995fcb9535843978768a0bc2a7b2921f8f183ba0bdb896fbb9a1c3dae4a11bb2a10467932bd636dbcbf73c99308a5498258be7cedcb2ad449daaceef515ae5aa6226df40f23a066716956aeb2aa69521f06e358406fdec86a659fffbf5dde3ebfc928439df691e4029df792fb1ea75e40dc15080fbc4fd52ba8d3cc2ceaf7739f8e4cbd747d4cde1df4beaa31ddd2a5d2f4120382ff3a8ae1e02db17cf6b3171f2c3683764221496e8058310a7667a011ea6cba1a58c3575a53f3e8c2ba3fb6ff31689349f66ee835370117b3335eaf8c49ecedd0a8702b58bb918a1785e177a53140653e34943e0a9c21d059eb8707e504cc4b3262bdda44830ed94a474798e46884b8107c9b8890e77df8768884d0296fa10013deff247728036e54e394ae31c970b79deb805026ac135676d36c112374d1ec333907ab82d9d76d7d26140729dd96ddd4caabfa1d062895457504e14f312b9c703681a0f637a9951a150781e43b1584375f8c1a7df8964c345d96abc297aee6116dc9c142c35b62aac3e4f3d81c790bce92377f4e858940b66578e4d56179df3e4964ae4c04ebbb2c366c07f3dcc0f93033b75b7c88edcf6f76b07c93d3d792cfe579dc3be3190c77f188a84c20248e60ff8492519c0e713d68005d9f02f7b21da19dcde528bf30be04994d0fd9a24d97f13ecbdb6581e262f6c1b85d79ca13a9b9cc652aa91631c5b5322b84e94521bcb89bdde1b0fc83a6060c2487b52faa73d2c2a379a60a5b14434cc5d7eb174445e7bf0066193358264d9ea6c965216458d3bf3a4892bc2d6cd720a02e08b5d8f398e79f65887031e83115ec544ef990069277f0e16611db24f9882a482d33d636e1b545d98fc07798b40c5474c857c5406ada1ba8910e41fba84ab1309be105be2092ac20d9b890017ce9b74910edd71001d30c8e494780f4fccdfed548db09c113845e71a8ed68814d16d531cd7645be5d4701eaa5b519a51f223d221a6793ac315a446d102a07fec00c6912d77ad63572cb86ede72044019881c510c8f168a3fffd701db67a0aa3b46ebb4c7554ffa90b413e0356f80f59dbbf5e7bb7dc518270c672d0e5eb0b4a245413f5956e6344d4ee4f79e623609c3e68f125b58c42bc4b1a10a83ba62ddf3c0c2f9ee27a6ed35004ea8222cf56080621ebdda7db622b1d13a62e7fc332783188fd82e79e82b5f24995f58c8565640722d0cb1bff01158334d871b9de698cf25a337a08b0f877bcb0c9369387a18d822f65d54d8c9ea2b208295f9ad53afc434f8432dc86f3d49e20132c62ca95d1ccfa5875ba6125eb4167b1ce4945c89bd2d42220bd0206f9302b25ab32822a33eba34af4e2958361bad38ac4b89910f5fb86e2915bb150b01e97677eeaea6dfe490ad814d76ae8201ae7372e0501b6207dbf35f597c193d44cb4e359e308873f4d25f50e3adfeb7eb2f537063d1f1ae7555d177a4b99939c2b2f74aed863297f888291eb5f5532f5d1433a472692263058e6a07cfdf70addb74d8fcbbb866e9e6535ee261c759116fd3abea32382bb820910ccc0f94a3260b2a2e845c2f89da63c5efdb74fb963fbf07ff7e843f4b7fab22f2fd116f71a659ea507684124480153f897bb341e95093b0f93a09eae09b6611f1d1e4ffc8dd658349ddfacbc20b1d8f786ce4183bf6ba13fe0e498e9d8d63bc947c9af42dddee51d914bed8ebd155ed1f63199e769509c881646045144b2f9151aaad7ba4ce3b5e2f604646c3e5e13c593ff7e60379ff4fa18af2adb123e343cbab758c4b46f4b95421717b20cd90048ead2091726a9edb42eb9258f816686baad8d212960a6f7cd0474bc7a50e956f66b5dafdf97e2dbebf80914d79948f00f203eb443a2d7f86251833d027931e0c55acf498df3a1b83607bd7c902ec6fbc4fc112011c48e9c1f69984097506e2df5be0b039a11bdccb4507934798b8e8804be3d10481eb6cb6bfb36adb3cb204aa895bbf96aa688b3d43cb9ece569280afdb0e218da5beeeaedb36f12b6ab81a3ebfcf0786b98ef42b1d5a090b460e48e54364878ce2886684c4b140f34a949ef3b430f18a7852ca517cba375df3a8f295c6bf492618ae90e645171028579c8c17c1bd23884546aaf5a299f242046da1c463ffbdc306808e93a345e0342ad2ecfd0288ef3128bcc8168b36d4bbd7f6b74c58ebef0584f9052eb0f2cb2c6b1e4187025e7446384b77b9202c3ca86426eb597b5d0b10107ebfdfd6c9a4d605bdeac4091e3d4035f47c57a760d9a2406b7909e60890f7bbb9ce120bd8c817997781f244eecdfb36076efc171a4eb167acbb89d472f4fecca1498313876f968d61155f1306c23cc3a4c4be7c317a49465b0c55efe6b28fc04a5e8607efcf2fe4dd49191377da2544db68a9db8492999d89e40a41594cc7b7a8c01d6726001ce4dedfa3e86ec53645eb5c2f538b0b032133ca8800365045979de08a0ab87d7e2f4cadab254add87b51f320c7a9dc16a35465737c75fba609c9a7160f5b04b5434c5c4dc7179718e461a8b4762fc171255ce81a1dbf02586c39e14391187405387faf314d4b3ccdadd261614c7ea60a436a073b4e2925ab4044b9d5147824777c9e665523734470cb7ea92a0cfa3c6e1b6d58fecb53c4f92b337454ee44ca838f4268ee8adc5cfceb7b8cc27a33eccaa23cfb0d9f97a597b1d835c1b1ba93e3a01db967ed34c4955a18e38fc64068fbcb2ed6f637d823285a9f8650d851ff3f5bc14ee0728bc357788fab63f53a1d4bf1c4163d5a7fbb89c3bbe490d99c76aedd355b2e422fc44d6dc29fe89e850692428c1b014f1fbfc0dcc84dbae6794b423cce09b57d8283826f766a2eaf1703bf694e5995916377d4583e43aacb4a6cce082642605e9f0f91e9b0c70ab3b67816e9d979be6e33379b9a95de4d9a46e03d5e1d04e005076701ca1ed0ef1ef8b0fe68dd8df008cee41d6be2f20a113579f4ff688ab8cdd54a9cbcd4f021603f4853b3efcdd5aec709ffe399b88017a6d6c819f46bab8709fc9b91814d3c7dbc99deadac2f7731e5ef529397e244326e2ff02b9a5a3132fe78da0ad40c802e23cfb09fb1840a6c7f6c3e3048e16ba95080397d06c7ce8ca4700392be9613fa0b78640514502a5bf1715fad5a74c5574a7fd7e83fe3fd3ed4120eb013229e66bf687370d1b7dd1e16cd9fe530a98602fbc02295c2a6d33ef066456335821c7fb4f91e00746202a245575273c3b8787d7a8883a501f7973706752867753f3f06f9688ed7d502ae646c58a468af86a2db08e6351d7c791d0cd2d2f449aea2ba79e9f1cbb3d4eaed44d9fb985231ae3481cc6b94062da513dec9f5d42ed6e23ca8e09cba2903d5219e29b6b3854b2fe0e087727d95048b95b235e8a55d17c62f3807054a1d6642093c44fb01233292c52e0263999d19778fe56918df9e656287bc174d39c562a491bbd08e7b1276f9d22d23fcd64a72140eaace0072b5d19e1324e7524c5be10b1fc16a830e873c6c05f36cd891b4ec7889c6d57d10297f6ef10f99f8de55fb3df1d3a08a51fe8b41f8e462af46af5e1d471a2a9ec3a39a32dca5a37b8f87ecf6e0a856a18b12a09c9ac5503169f3aaa60312846adb9141086fd2774380f4d62e1eacc1e8c4d6e803a601a91e4c33ef0e5a08eb8f8e66f97123155bf1c9094dadacab0d7f17f948ae514ad9d2cbc30ee3c733468786fe3117ef4252c0722b993bc6b5dfa1665e888d11bb58bb304ecf64da01553c3904c5d763c66810437d8bca6b71d64fd779e70b0f28b6ef801013eb776876f22ad4c0bcdd9413464c1145e4bdcd2708905dda0146578a7a5a55a8642775b81ae0387faa0a4c1c5ae70c8667504ca261fdc75c9ecb8d8dafa0d6dedefb5a813f623f3b704c8c68ea280e28cd5ca77dc87051d1d82113f4bdba7da1069dbc2c78ecc11ea36365474ffb9fb032048f14215684395b11890d64f6346996818ef52955b6b6efcae5e458e53aeac37941ad15ac80e1d555d9afb3f0f81540b1c1d236806baa3b4add5ef55eb1f59d5ffe9d10c09ed60e8723385531148612a934a276095967f32f142d61410d0eabb93f25052b019734174c503e75f74c667b4e498155d8f7b985254870b4666a72b98d3671ddee9ffe7457e84b6bb9239ed87a02e23db20f8e47edea2fc582cba7e1e3453b87efe5a9fd5ca78a900dcb37f50c071a66c7afa1e1424010669c00b3d5a83ee7ca5cc607ee2bfb67aec0194674a3cd52a5a3083429cb6cc7ad521971726efeaa2bd46be68fdc767ddb3ab2d0762374b966cf7f8343fe0a47176be2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"446c3d90727033a907924f811a1029ea"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
